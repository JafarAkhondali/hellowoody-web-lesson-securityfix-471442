<script>
/*
Symbol 类型

一个不透明且无法预测的值（从技术角度来说就是一个字符串）。

Symbol（符号）是 ECMAScript 6 新增的数据类型。
符号是原始值，且符号实例是唯一、不可变的。
符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。
尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的（尤其是因为Object API 提供了方法，可以更方便地发现符号属性）。
相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。

简单理解：
    a.ES6推出的语法，但是2023年这个时间点，基本所有浏览器都支持了。
    b.它是浏览器帮我们维护一套不可能重复的值

Symbol 不是构造器/构造函数，所以不能new Symbal
*/ 

// 基本使用

let s1 = Symbol()
console.log(typeof s1) // symbol
console.log("s1:",s1)  

try {
    let s2 = new Symbol()
} catch (error) {
    console.log(error)
}

let s2 = Symbol("s2")
console.log("s2:",s2)
let s2_copy = Symbol("s2")
console.log("s2_copy:",s2)

console.log("s1 === s2:",s1 === s2)
console.log("s2 === s2_copy:",s2 === s2_copy)


/*
使用全局符号注册

 如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，
 在全局符号注册表中创建并重用符号。

 Symbol.for()对每个字符串键都执行幂等操作。
 第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，
 于是就会生成一个新符号实例并添加到注册表中。
 后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，
 然后就会返回该符号实例。
*/

let fooGlobalSymbol = Symbol.for('foo'); 
console.log(typeof fooGlobalSymbol); // symbol
console.log(fooGlobalSymbol); 

let s3 = Symbol.for("s3")
let s3_copy = Symbol.for("s3") // 不创建新的symbol，找到之前同参数的symbol并返回

console.log("s3 === s3_copy",s3 === s3_copy) // true

/*
Symbol("123")       基本使用
Symbol.for("123")   全局符号注册

这两种操作是不一样的
*/ 

let s4_basic = Symbol('foo'); 
let s4_global = Symbol.for('foo'); 
console.log("s4_basic",s4_basic)
console.log("s4_global",s4_global)
console.log(s4_basic === s4_global); // false

/*
let a; // undefined  "undefined"
Symbol.for(a)  //Symbol.for(undefined)

Symbol.for()   // Symbol.for(undefined)
*/

const s5_basic = Symbol()
const s5_global = Symbol.for()

console.log("s5_basic:",s5_basic)    // Symbol()
console.log("s5_global:",s5_global)  // Symbol.for(undefined)


/*
    Symbol.keyFor()来查询全局注册表
    这个方法接收符号，返回该全局符号对应的字符串键。
    如果查询的不是全局符号，则返回 undefined
*/  
// 创建全局符号
let s6 = Symbol.for('foo'); 
console.log(Symbol.keyFor(s6)); // foo 
// 创建普通符号
let s7 = Symbol('bar'); 
console.log(Symbol.keyFor(s7)); // undefined 
// 如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError：
try {
    Symbol.keyFor(123); // TypeError: 123 is not a symbol
} catch (e) {
    console.log(e)
}

/*
Symbol 的作用

使用符号作为属性

*/

const s8 = Symbol("p1"),
      s9 = Symbol("p2");

const obj = {
    [s8]:"hello s8",
}

console.log("obj:",obj)
console.log("obj[s8]:",obj[s8]) // "hello s8"

console.log("s8 config:",Object.getOwnPropertyDescriptor(obj,s8))

Object.defineProperty(obj,s9,{
    value:"你好 s9",
    configurable:true,
    enumerable:true,
    writable:true,
})

console.log("obj:",obj)
console.log("obj[s9]:",obj[s9])


// 不要这样用symbol， 因为不太好取到属性值
const obj2 = {
    [Symbol("p3")]:123
}

console.log("obj2:",obj2)

/*

    let s10 = Symbol('foo'), 
        s11 = Symbol('bar'); 
    let o = { 
        [s10]: 'foo val', 
        [s11]: 'bar val', 
        baz: 'baz val', 
        qux: 'qux val' 
    }; 

    Object.getOwnPropertySymbols(o)  // [Symbol(foo), Symbol(bar)] 
    Object.getOwnPropertyNames(o)    // ["baz","qux"] 
    Reflect.ownKeys(o)               // ["baz", "qux", Symbol(foo), Symbol(bar)]
*/

let s10 = Symbol('foo'), 
    s11 = Symbol('bar'); 
let o = { 
    [s10]: 'foo val', 
    [s11]: 'bar val', 
    baz: 'baz val', 
    qux: 'qux val' 
};

console.log("all symbol keys :",Object.getOwnPropertySymbols(o))
console.log("all normal keys :",Object.getOwnPropertyNames(o))
console.log("all keys :",Reflect.ownKeys(o))


/*

常用的内置符号 （有很多，这里只介绍迭代内置符号）

这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。
比如，我们知道for-of 循环会在相关对象上使用 Symbol.iterator 属性，
那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，
来改变 for-of 在迭代该对象时的行为。 

for-of 用来遍历数组，所以数组对象肯定有内置符号
而官方定义迭代的内置符号：Symbol.iterator 

const arr = []
console.log(arr[Symbol.iterator])
*/

const arr = [1,2,3]

console.log("arr[Symbol.iterator]",arr[Symbol.iterator])
const it = arr[Symbol.iterator]()
console.log(it.next())
console.log(it.next())
console.log(it.next())
console.log(it.next())
console.log(it.next())

for(const _ of arr){
    console.log("arr item:",_)
}

// arr[Symbol.iterator] = function(){}  
arr[Symbol.iterator] = function(){
    let i = 3
    return {
        next:function(){
            if(i > 0){
                i--
                return {value:i,done:false}
            }else{
                return {value:undefined,done:true}
            }
            
        }
    }
}  

for(const _ of arr){
    console.log("1000 arr item:",_)
}

// for-of
// {}

// const o2 = {
//     name:"hello o2",
//     limit:5,
// }

function O2(){
    this.name = "hello o2"
    this.limit = 5
}

const o2 = new O2()

// o2.__proto__[Symbol.iterator] = function(){
O2.prototype[Symbol.iterator] = function(){
    console.log(2000)
    // console.log(this)
    let that = this
    return {
        // obj增强语法
        next(){
            if(that.limit > 0){
                return {value:("这个对象可迭代"+that.limit--),done:false}
            }else{
                return {done:true}
            }
        }
    }
}

// console.log(o2[Symbol.iterator]())
// const o2it = o2[Symbol.iterator]()
// console.log(o2it.next())
// console.log(o2it.next())
// console.log(o2it.next())
// console.log(o2it.next())
// console.log(o2it.next())

for(const _ of o2){
    console.log(_)
} 











</script>