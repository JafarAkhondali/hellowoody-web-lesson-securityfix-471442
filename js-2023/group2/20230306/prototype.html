<script>
/*
1.原型和原型链不是一个东西

2.构造函数/构造器：首字母是大写的函数

    function Foo(){

    }

3.构造函数/构造器的用途是创建对象的
    function Foo(){
        this.a = 1;
        this.b = 2;
        // 注意 正常的构造函数不能有return
        // 如果 构造函数有return，那它自动被当作普通函数对待
    }

*/ 

function Foo(){
    this.a = 1;
    this.b = 2;
}

function Bar(){
    this.a = 1;
    this.b = 2;
    return {
        name:"zhangsan"
    }
}

const foo = new Foo()
const bar = new Bar()

console.log("foo:",foo)
console.log("foo.a:",foo.a)
console.log("bar:",bar)
console.log("bar.name:",bar.name)
console.log("bar.a:",bar.a)

/*

4.构造器constructor，实例instance，原型prototype三者的关系

constructor                          一般是我们创建或定义的（首字母大写的函数）
instance                             是new constructor的返回值
instance.__proto__                   __proto__是实例的属性，可以帮我们获得“原型链”上的原型对象
constructor.prototype                prototype是构造器的属性，可以帮我们构造器的原型对象
constructor.prototype.constructor    原型对象上的构造器属性，是一开始的构造函数。（原型对象上的构造器属性和构造器互为引用）

// constructor.prototype.constructor === constructor
Foo.prototype.constructor === Foo

注意：什么叫原型对象，只要含有一个属性名为construrtor的对象，就可以称为原型对象
console中打印Foo.prototype.constructor，显示的就是函数本身
*/ 

function Person(){
    this.speak = function(){
        console.log("speaking")
    };
    this.age = -1;
    this.name = ""
}

const p = new Person

console.log(Person.prototype)
console.log(Person.prototype.constructor)
console.log(Person.prototype.constructor === Person) // true
console.log(p.__proto__)
console.log(p.__proto__.constructor)
console.log(p.__proto__.constructor === Person)      // true


/*
5.原型prototype的用途

    可以在程序运行时增加属性和方法

*/

function Model(a,b){
    this.a = a
    this.b = b
    this.desc = function(){
        console.log(`a:${a},b:${b}`)
    }
}

const m1 = new Model(1,2)
const m2 = new Model("哈哈","呵呵")

m1.desc()
m2.desc()

m1.sum = function(num1,num2){
    console.log(num1+num2)
}

m1.sum(1,2)
try{
    m2.sum(1,2)
}catch(e){
    console.log("抓到错误了：",e)
}


Model.prototype.sub = function(n1,n2){
    console.log(n1-n2)
}

m1.sub(5,2)
m2.sub(1,2)
const m3 = new Model("一","二")
m3.desc()
m3.sub(0,10)

/*
6.原型链的用途呢？

    const arr = new Array("a","b")
    // const arr = ["a","b"]

    把原型链想象成一条绳子

     "绳子"的一端          "绳子"的另一端
        arr  ->  Array -> Object

            Array原型上没有valueOf方法
            Object原型上有valueOf方法
            所以 arr.valueOf() 可以调用

            Array原型上有toString()方法
            Object原型上也有toString()方法
            所以 arr.toString(() 调用的是Array原型上的方法

    原型链的作用就是实例arr可以调用这条“绳子”上的任意原型对象上的方法
    注意：如果方法有重名情况，按就近原则（距离实例最近）获取方法
*/ 

const arr = new Array("a","b")
console.log(arr)
console.log(arr.__proto__) // Array 原型对象
console.log(arr.__proto__.__proto__) // Object 原型对象

console.log(arr.join("-"))           // Array方法
console.log(arr.valueOf())           // Object的方法
console.log(arr.toString())           // "就近原则" Array的toString()

/*
进阶，比较难

使用原型链实现面向对象中的“继承”

注意：严格讲，在js中并不是真正的“继承”，
            但我们一般用这样比较好理解的叫法形容它
*/ 

function Animal(){
    this.heart = 90
}

const aaa = new Animal()


function Dog(){
    this.swimming = function(){
        console.log("i am swimming")
    }
}

Dog.prototype = new Animal()        // 将Animal的属性/方法给了Dog
Dog.prototype.constructor = Dog     // 让原型链完整

const dog = new Dog()
console.log(dog)
console.log(dog.heart)
console.log(dog.swimming())

console.log(Dog.prototype.constructor === Dog)
console.log(Dog.prototype.constructor === Animal)
</script>